:PROPERTIES:
:ID:       9adf4202-9e48-4f16-915c-fc8fb4949ca1
:END:
#+title: From Javascript to Python
#+Property: header-args :exports both
#+filetags: :article:teaching:

This will cover some of Python, for another good introduction to the language refer to [[https://www.codecademy.com/learn]].


Similarly to Javascript Python in an interpreted language. It has a less "verbose" syntax than JS hovwever,
and some particular advantages.

Let's look at some fundamental differences:

* Variables
In JavaScript we declare variables with keywords such as ~let~, ~var~, ~const~. Python does not have that,
we just create a variable by assigning it a value.
E.g Javascript's
#+begin_example javascript
var a = 10;
var b = 100;
#+end_example
would be
#+BEGIN_SRC jupyter-python :session py
a = 10
b = 10
#+END_SRC
Note that we do not need the semicolons (actually we don't need those in JS either, it is a convention).

* Comments
We do want to write comments in our code right? This will keep you and who is evaluating your code sane.
In Javascript we have two syntaxes to write comments:
#+begin_example javascript
// This syntax for a single line comment
#+end_example
and
#+begin_example javascript
/* This syntax for
(potentially) multi-line comments */
#+end_example
In python we use the ~#~ symbol to demarkate a comment
#+BEGIN_SRC jupyter-python :session py
# This is a common Python comment
a = 20 # It can be put on the same line
#+END_SRC
Another way you might come across for multiline comments is the following:
#+BEGIN_SRC jupyter-python :session py
''' This is a multiline comment
    with longer text
    ...and more text'''
#+END_SRC
The latter is actually a "multiline string", which is delimited by three single quotes ~'''~.
For example
#+BEGIN_SRC jupyter-python :session py
multiline_text = '''This string will contain newlines
when I enter a newline in the definition'''
#+END_SRC

* Strings
We have seen an example of a multiline string above, which can be used also as a comment (usually an important one, e.g. the documentation of a function). Otherwise we can define strings similarly to Javascript with either single quotes ~'Hello'~ and double quotes ~"Hello"~ . We can use either as long as we are consistent (e.g. ~"Hello`~ will not work).

The ~+~ operator concatenates two strings, e.g.
#+BEGIN_SRC jupyter-python :session py
"Hello" + " ,world!"
#+END_SRC

and we can convert a number or other object to a string using the ~str~ keyword. E.g.
#+BEGIN_SRC jupyter-python :session py
"Hello class of " + str(50)
#+END_SRC

There are other more sophisticated ways to create strings. E.g. using the [[https://www.w3schools.com/python/ref_string_format.asp]["format"]] approach or using a [[https://www.learnpython.org/en/String_Formatting][formatting syntax similar to C/C++]].

* Identation and scope
Now to the biggest difference. In Javascript we enclose "content", such as the
body of a function, or the operations following an ~if~ statement, with curly
braces (~{~ and ~}~). The curly braces define what is known as "scope".

#+begin_example javascript
function doSomething() {
    if (a == 10){
        print("A is 10");
    }else if (a==5){
        print("A is 5");
    }else{
        print("A is something else")
    }
}
#+end_example

Let's look at the same function in Python:
#+BEGIN_SRC jupyter-python :session py
def doSomething():
    if a==10:
        print("A is 10")
    elif a==5:
        print("A is 5")
    else:
        print("A is something else")
#+END_SRC
So we have the same ~()~ syntax for the defining functions but instead of
~function~ we use ~def~ and most importantly we define scope using a colon ~:~
followed by a new line and an *indentation*. In practice, when you write *clean*
javascript you follow a similar procedure. So if you remove the opening curly
braces in the example above with a colon, replace ~function~ with ~def~ and
remove the closing ~}~ we basically are done with translating the code. Note
that we can write ~if a==10~ without the parentheses. Indeed for ~if~ statements
or other basic statements (e.g. ~for~, ~while~) the parentheses are optional in
Python. Not a problem if you use them though.
Note also that istead of ~else if~, Python uses the ~elif~ keyword.

* Lists, iterables, dictionaries and sets
Python offers quite powerful default containers that have similarities to Javascript.
Let's start with [[https://www.w3schools.com/python/python_lists.asp][lists]], which are very similar to Javascript's ~Array~ but have a more concise syntax.
*** Lists
A ~list~, similarly to an ~Array~ in Javascript, can be simply created using square brackets:
#+BEGIN_SRC jupyter-python :session py
myList = [0, 1, 4, 6, 10]
#+END_SRC
we can index the list using square brackets, e.g.
#+BEGIN_SRC jupyter-python :session py
myList[2]
#+END_SRC
will give us the third element in the list (starting from ~0~, like JS).
We can also set an element (as long as the list has enough elements) with the same syntax
#+BEGIN_SRC jupyter-python :session py
myList[2] = 10000
#+END_SRC

We can add or "pop" elements from a list similarly to Javascript, but using the
~append~ and ~pop~ methods (these are equivalent to ~push~ and ~pop~ in
javascript). E.g let's create an empty list and add two strings to it:
#+BEGIN_SRC jupyter-python :session py
myList = []
myList.append("Hello")
myList.append(", ")
myList.append("World")
#+END_SRC

#+RESULTS:

By default the ~pop~ keyword will remove the last element of the list and return it, for example
#+BEGIN_SRC jupyter-python :session py
print(myList.pop())
#+END_SRC
We can also give pop an index, so
#+BEGIN_SRC jupyter-python :session py
myList.pop(0)
#+END_SRC
will remove the /first/ element from the list and return it.

While in Javascript we used the ~length~ property to get the size of an array, in Python we get the number of elements in a list (or in other types of objects as well, such as strings) with the ~len~ function. E.g.
#+BEGIN_SRC jupyter-python :session py
num_elements = len(myList)
print(num_elements)
name = "hello"
print(len(name)) # This give us the length of the string
#+END_SRC

*** Indexing and slicing lists
One nice feature of Python is that we can index a list backwards! For instance
~myList[-1]~ will give us the last element of the list, ~myList[-2]~ the second to last, and so forth...

In addition, and more on this later, we can easily slice up a list. We will not cover every technique here but for example we can get the first three elements of a list:
#+BEGIN_SRC jupyter-python :session py
elements = [0, 1, 3, 5, 7]
elements[:3]
#+END_SRC
or for example skip the first two elements with:
#+BEGIN_SRC jupyter-python :session py
elements[2:]
#+END_SRC
or skip the fist and last element with:
#+BEGIN_SRC jupyter-python :session py
elements[1:-1]
#+END_SRC
Experiment with the code to get a feel of what is possible and more information can be found here [[https://www.learnbyexample.org/python-list-slicing/]].



** Iterables and loops
Python has another quite drastic difference from Javascript and other languages in the way we construct loops. In Javascript we have encountered the typical ~for~ loop contruct
#+begin_example javascript
for (let i = 0; i < 10; i++){
    print(i)
}
#+end_example
and this does not really exist in Python. To do an equivalent for loop we would write:
#+BEGIN_SRC jupyter-python :session py
for i in range(10):
    print(i)
#+END_SRC
here [[https://www.w3schools.com/python/ref_func_range.asp][range]] is a function that returns an object that can be iterated. It is similar to a ~list~, but it is actually known as a [[https://www.programiz.com/python-programming/generator][generator]]. We will not go into details on generators here, but these are objects that spit out an ordered sequence of elements. The syntax ~range(10)~ gives us a sequence of numbers from zero to 100. We can display it by converting it to a list with
#+BEGIN_SRC jupyter-python :session py
list(range(10))
#+END_SRC
The ~for~ keyword essentially extracts elements from an object that can be iterated. This object can be a generator (such as a ~range~) or a list. For example using the earlier list:
#+BEGIN_SRC jupyter-python :session py
for s in myList:
    print(s)
#+END_SRC
goes through the list. This may look strange at first, but it is a very powerful construct. A perhaps useful way of thinking of it is to see the ~for~ as a machine that sequentially extracts elements from a list, or an object that can be iterated, until these elements are finished.
As another example, say we want to loop through the characters of the string "hello world". Since also strings are iteratable, we can simply do:
#+BEGIN_SRC jupyter-python :session py
for c in "hello world":
    print(c)
#+END_SRC

We will see later many other useful ways to generate lists or arrays that can be iterated with ~for~.

**** List comprehensions (extra)
A perhaps cryptic looking construct that is very much used in Python, and is worth knowing about is a "list comprehension". Essentially this is a concise way of generating lists using for loops inside the brackets that define the list.
E.g. say we wanted to have a list with the length of each string in our ~myList~ list.
We can do
#+BEGIN_SRC jupyter-python :session py
lengths = [len(string) for string in myList]
#+END_SRC
Reading this out loud would be
#+begin_quote
Create a list (using an opening ~[~) and put ~len(string)~ into each element of the list, for each ~string~ contained in ~myList~. Finish creating the list (closing ~]~)
#+end_quote

Even more powerful, we can filter out elements by even adding an if statement at the end of this expression. E.g.
#+BEGIN_SRC jupyter-python :session py
[string for string in myList if string[0]=='H']
#+END_SRC
will give us a new list, where an element is present only if it starts with the "H". So if our list is unchanged, it will contain only one element.


** Tuples
The ~tuple~ object in Python is an iterable object very similar to a ~list~, with the main difference that it is *immutable*. We create it with opening and closing round brackets. E.g.
#+BEGIN_SRC jupyter-python :session py
vals = (10, 20, 30)
#+END_SRC

#+RESULTS:

However, while for the case of a list we could assign an element, for tuples this is not possible. E.g
#+BEGIN_SRC jupyter-python :session py
vals[0] = 1
#+END_SRC

#+RESULTS:
:RESULTS:
# [goto error]
: ---------------------------------------------------------------------------
: TypeError                                 Traceback (most recent call last)
: /var/folders/sr/zs7syfx13zzfn32_m3hpw17c0000gn/T/ipykernel_11804/311428616.py in <cell line: 1>()
: ----> 1 vals[0] = 1
:
: TypeError: 'tuple' object does not support item assignment
:END:
will give us an error.

*** Using tuples in practice
You will often see tuples "hidden" in Python code, as they can be defined and assigned also without the use of the parenthesis. E.g.
#+BEGIN_SRC jupyter-python :session py
vals = 10, 20, 30
#+END_SRC
Is perfectly equivalent to the code above using the ~(10, 20, 30)~ syntax. Well, why is this ueful? We can do some really concise expressions, for example we can write:
#+BEGIN_SRC jupyter-python :session py
a, b, c = 10, 20, 30
#+END_SRC
and this will assign 10, 20, 30 to ~a~, ~b~ and ~c~ respectively.
Or we can swap a and b with simply
#+BEGIN_SRC jupyter-python :session py
a, b = b, a
#+END_SRC
Or for example we can iterate more conveniently over a list of tuples
#+BEGIN_SRC jupyter-python :session py
for a, b in [(2, 4), (2, 5)]:
    print(a + b)
#+END_SRC
We will see another practical application of this later with dictionaries.

**** A note on assignments and references in Python
Similarly to Javascript, in most cases ewhen we create an object such as a list,
assigning it to another variable will not copy the object but just refer to the
same object. This is true for lists for example:
#+BEGIN_SRC jupyter-python :session py
list_a = [0, 2, 3]
list_b = list_a
print(list_b)
list_a[2] = 100
print(list_b)
#+END_SRC
This is not true for tuples as they are immutable. So assigning a ~tuple~ will create a copy of it. The same holds for strings.


** Dictionaries
Another important Python object is a [[https://www.w3schools.com/python/python_dictionaries.asp][dict]], a "dictionary" very similar also in syntax to Javasript objects and it is a collection of key:value pairs.
#+BEGIN_SRC jupyter-python :session py
mydict = {"name": "John",
          "surname": "Doe",
          "age": 360}
#+END_SRC
A bit less conveniently than Javascript we cannot use the ~.~ to access the
elements in a dictionary. We need to explicitly give the key inside square
brackets, e.g.
#+BEGIN_SRC jupyter-python :session py
mydict['age']
#+END_SRC
will give us the value of the entry with key "age".

Dictionaries are also iterable, but with some subtleties. We can iterate over
all the key, value pairs with the ~.items()~ method, which iterates over all the
(key, value) pairs in the dictionary. These are given as tuples so we have:
#+BEGIN_SRC jupyter-python :session py
for key, value in mydict.items():
    print(key + ' ' + str(value))
#+END_SRC

Otherwise we can just get the keys with ~.keys()~ or only the values with ~.values()~.

** Sets
Sets are unordered collections of elements that are unique. Say we want to remove duplicates from a list, we can do:
#+BEGIN_SRC jupyter-python :session py
l = [1, 2, 2, 3, 5]
print(set(l))
#+END_SRC
If you need more information on sets refer to [[https://www.w3schools.com/python/python_sets.asp]].

* Packages and modules
Apart from being a powerful languages, one of the most attractive features of
Python is the availability of a immense variety of "packages", extensions that
allow to achieve all kinds of functionality. A package is a collection of
/modules/ that are organized in a directory structure and can be imported into
other programs to use their functionality. A module is a single file that
contains definitions and statements, and can include functions, classes, and
variables.

As an example, you can create a file called ~my_functions.py~ and place it in
the same directory as your main Python file or notebook. You can then ~import~
the module with ~import my_functions~ and use the functions contained in the
~my_functions.py~ file with the "dot notation", for example ~my_functions.add(3,
2)~. Python also has a number of built-in modules. For example to access a
number of mathematical operations one can use the ~math~ module:
#+BEGIN_SRC jupyter-python :session py
import math
math.sqrt(2)
#+END_SRC

#+RESULTS:
: 1.4142135623730951

Packages allow you to further structure code by grouping related modules
together. For example, later on we will use the ~matplotlib~ package and import
a specific submodule with
#+BEGIN_SRC jupyter-python :session py
from matplotlib import pyplot
#+END_SRC
An alternative notation is the following:
#+BEGIN_SRC jupyter-python :session py
import matplotlib.pyplot as plt
#+END_SRC
and here we explicitly thell Python how we want to refer to the module. This is
often used to abbreviate the name of the module in order to reduce typing.
Another example of this syntax that we will use is:
#+BEGIN_SRC jupyter-python :session py
import numpy as np
#+END_SRC
Here numpy as a package that immediately provides a set of functionalities
without requiring to specify the specific submodule.
